package ru.runa.gpd.editor.graphiti;

import org.eclipse.graphiti.features.IFeature;

/**
 * Это маркерный интерфейс. В данное время, применяется для потомков LayoutElementFeature, но может быть применён для других классов, если
 * понадобится. Используется здесь ru.runa.gpd.editor.graphiti.CustomCommandStack.historyNotification(OperationHistoryEvent). Суть в том, что для
 * правильной обработки feature механизмами undo/redo важно, чтобы метод org.eclipse.graphiti.features.IFeature.hasDoneChanges() возвращал значение,
 * соответствующее замыслам создателей ) Об этом написано даже в джавадоке этого метода. Особенно обрати внимание на "IMPORTANT NOTE". Единственное, о
 * чем они не написали, это собственно какое именно значение должно иметь это поле. И это одна из причин, по которой, в прежних реализациях, несмотря
 * на все усилия, не работало undo/redo. Методом экспериментов я выяснил следующее правило: Если выполняется, как команда верхнего уровня и должна
 * откатываться/накатываться то hasDoneChanges должна быть true Если выполняется, как команда верхнего уровня и НЕ должна откатываться/накатываться то
 * hasDoneChanges должна быть false Если, выполняется, как часть транзакции, то должна быть true
 * 
 * Одни фичи всегда выполняются отдельными транзакциями, другие - всегда, как часть транзакции. Но некоторые, (особо хитрые) такие как LayoutFeatures
 * в некоторых случаях выполняются на верхнем уровне, а в некоторых - как часть транзакции. Таким простым способом для каждого из этих случаев я
 * автоматически присваиваю им значение hasDoneChanges ожидаемое Eclipse.
 *
 */
public interface IDoneChangesFeature extends IFeature {

    public void setHasDoneChanges(boolean hasDoneChanges);

}
